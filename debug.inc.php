<?php
/**
 * Debug include functions, Make it easier to debug your PHP code.
 *
 * This file contains a number of functions to make it easier to debug
 * your PHP scripts.
 *
 * PHP version 5, 7 and 8
 *
 * @category Debug
 * @package  Debug
 * @author   Evan Wills <evan.i.wills@gmail.com>
 * @license  GPL 2.0 https://www.gnu.org/licenses/old-licenses/gpl-2.0.en.html
 * @link     https://github.com/evanwills/php-utils
 */

/**
 * The following IF statement allows debug.inc.php to be included any
 * number of times so files that have been independantly tested won't
 * throw errors.
 */
if (!function_exists('debug')) {
    /**
     * Display the file name and line number it is being called
     * from (relative to the original script) and the string value or
     * variable name and value of any number of supplied arguments.
     *
     * NOTE: only variables (& constants) declared outside of
     *       functions are in the global scope so only those variable
     *       (& constants) names are accessible.
     *       debug() will not be able to report the names of variables
     *       declared within functions (or classes).
     *
     * There are a number of reserved (case insensitive) strings which
     * cause debug() to output specific data.
     * These reserved strings are:
     * * `help`:      Help information about the debug function
     * * `backtrace`: The contents of an array generated by debug_backtrace()
     * * `server`:    The contents of the $_SERVER global array
     * * `request`:   The contents of the $_REQUEST global array
     * * `get`:       The contents of the $_GET global array
     * * `post`:      The contents of the $_POST global array
     * * `env`:       The contents of the $_ENV global array
     * * `files`:     The contents of the $_FILES global array
     * * `session`:   The contents of the $_SESSION global array
     * * `cookie`:    The contents of the $_COOKIE global array
     * * `globals`:   The contents of the $GLOBALS global array
     *                (will also accept global)
     * * `force_die`: Causes the debug function to kill the script
     *                after a given number of times (defined by
     *                max_times) (will also accept 'force die',
     *                'force-die', 'forcedie')
     * * `max_times=X`: Defines the maximum number of times debug()
     *                will be called within a given loop
     * * `meta_level=X`: Causes the file name and line number to
     *                change to one of the parent files/functions
     *                of the file/function calling debug()
     * * `config`:    configuration settings applied to debug();
     * * `return`:    return value of output;
     *
     * @return void,string
     */
    function debug()
    {
        $current_globals = Debug__scriptVarsOnly();
        $current_constants = Debug__scriptConstOnly();
        $output = '';
        $max_times = 0;
        $force_die = false;
        $continue = true;
        $included = debug_backtrace();
        $debug_line = $included[0]['line'];
        $debug_file = $included[0]['file'];
        unset($included);

        // ==================================================================
        // START: Debug__maxTimes sub function


        // END: Debug__maxTimes sub function
        // ==================================================================

        if (!defined('DEBUG__STATE')) {
            define('DEBUG__STATE', false);
        }
        if (!defined('DEBUG__MODE')) {
            define('DEBUG__MODE', 'echo');
        }

        if (DEBUG__STATE === true || !defined('DEBUG__DISCONTINUE_'.$debug_line)) {
            $line = '';

            $through_put = '';
            $debug_args = func_get_args();
            $check_help_next = false;
            $debug_mode = DEBUG__MODE;

            for ($a = 0; $a < func_num_args(); $a += 1) {
                $var_name = array(
                    'name' => '',
                    'extra' => '',
                    'count' => 0,
                    'space' => ''
                );
                $var_value = $debug_args[$a];
                //===============================================

                Debug__getVarName($var_value, $var_name, $current_globals);
                Debug__getConstName($var_value, $var_name, $current_constants);

                if (!empty($var_name['extra'])) {
                    $var_name['name'] .= '(or '.$var_name['extra'].') = ';
                } elseif ($var_name['name'] != '') {
                    $var_name['name'] .= '= ';
                }

                unset($var_name['extra'], $var_name['space'], $var_name['count']);
                $var_name = $var_name['name'];

                //===============================================
                $var_type = gettype($var_value);

                switch ($var_type) {
                case 'string':
                    switch(strtolower($var_value))
                    {
                    case 'help':
                    case '?':
                        $b = $a+1;
                        $help_next = '';
                        if (isset($debug_args[$b]) && is_string($debug_args[$b])) {
                            switch ($debug_args[$b]) {
                            case '':
                                $help_next = $debug_args[$b];
                                $a += 1;
                                break;
                            }
                        }
                        $var_name = Debug__help($help_next);
                        $var_value = '';
                        unset($b, $help_next);
                        break;

                    case 'backtrace':
                        $var_name = 'BACKTRACE: ';
                        $var_value = debug_backtrace();
                        break;

                    case 'server':
                        $var_name = '$_SERVER: ';
                        $var_value = $_SERVER;
                        break;

                    case 'request':
                        $var_name = '$_REQUEST: ';
                        $var_value = $_REQUEST;
                        break;

                    case 'get':
                        $var_name = '$_GET: ';
                        $var_value = $_GET;
                        break;

                    case 'post':
                        $var_name = '$_POST: ';
                        $var_value = $_POST;
                        break;

                    case 'env':
                        $var_name = '$_ENV: ';
                        $var_value = $_ENV;
                        break;

                    case 'files':
                        $var_name = '$_FILES: ';
                        $var_value = $_FILES;
                        break;

                    case 'session':
                        $var_name = '$_SESSION: ';
                        $var_value = $_SESSION;
                        break;

                    case 'cookie':
                        $var_name = '$_COOKIE: ';
                        $var_value = $_COOKIE;
                        break;

                    case 'global':
                    case 'globals':
                        $var_name = '$GLOBALS: ';
                        $var_value = $GLOBALS;
                        break;

                    case 'forcedie':
                    case 'force die':
                    case 'force_die':
                    case 'force-die':
                        $force_die = true;
                        $line = '';
                        $var_value = '';
                        $var_name = '';
                        break;

                    case 'return':
                        $debug_mode = 'return';
                        $var_value = '';
                        $var_name = '';
                        break;
                    case 'config':
                        // $var_value = 'Sorry this functionality'.
                        //              'hasn\'t been implemented yet';
                        $var_name = 'Debug configuration constants = ';
                        $var_value = array();
                        $current_const = get_defined_constants();
                        foreach ($current_const as $const_name => $const_value) {
                            if (preg_match('/^DEBUG_/', $const_name)) {
                                $var_value[$const_name] = $const_value;
                            };
                        };
                        break;

                    case 'constant':
                    case 'constants':
                        Debug__getConstName(
                            $var_value, $var_name, $current_constants, true
                        );
                        break;

                    default:
                        $reg = '/^(max[- _]?times|meta[- _]?level) ?(?:= ?)?([0-9]*)$/'; // phpcs:ignore
                        if (preg_match($reg, $var_value, $matches)) {
                            switch($matches[1])
                            {
                            case 'maxtimes':
                            case 'max-times':
                            case 'max times':
                            case 'max_times':
                                if (!isset($matches[2]) || empty($matches[2])) {
                                    $max_times = DEBUG__MAX_MAX_TIMES;
                                } else {
                                    $max_times = $matches[2];
                                }

                                $continue = Debug__maxTimes(
                                    $max_times, $debug_line, $debug_file
                                );
                                $line = '';
                                $var_value = '';
                                $var_name = '';
                                break;

                            case 'metalevel':
                            case 'meta-level':
                            case 'meta_level':
                            case 'meta level':
                                $included = debug_backtrace();

                                if (isset($matches[2])) {
                                    $meta_max = count($included);

                                    if ($matches[2] < $meta_max) {
                                        $meta_level = $matches[2];
                                    } else {
                                        $meta_level = $meta_max - 1;
                                    }

                                    $debug_line = $included[$meta_level]['line'];
                                    $debug_file = $included[$meta_level]['file'];
                                    unset($meta_max, $meta_level);
                                }

                                unset($included);
                                $var_value = '';
                                $var_name = '';
                                break;
                            }
                        } elseif ($var_value === '') {
                            $var_value = '"" (empty string)';
                            if ($var_name == '') {
                                $var_name = '[STRING]: ';
                            }
                        } else {
                            $var_value = Debug__sepcialChars($var_value);
                            if ($var_name == '') {
                                $var_name = '[STRING]: ';
                            }
                        }
                        break;
                    }
                    break;

                    // case 'array': // because $var_type = 'string' sometimes causes
                    //     break;    // $var_value to become an array. We check if it
                    //               // is an array outside this switch statement.

                case 'boolean':
                    if ($var_value === false) {
                        $var_value = 'FALSE';
                    } elseif ($var_value === true) {
                        $var_value = 'TRUE';
                    }

                    if ($var_name == '') {
                        $var_name = '['.strtoupper($var_type).']: ';
                    } else {
                        $var_value .= " ($var_type)";
                    }
                    break;

                case 'integer':
                case 'double':
                case 'unknown type':
                case 'NULL':
                    if ($var_name == '') {
                        $var_name = '['.strtoupper($var_type).']: ';
                    } else {
                        $var_value .= " ($var_type)";
                    }
                    break;

                case 'object':
                case 'resource':
                    $var_value = $var_type;
                    break;
                };

                if (is_array($var_value)) {
                    $var_value = print_r($var_value, true);
                    $var_value = Debug__sepcialChars($var_value);
                }

                $through_put .= $line.$var_name.$var_value;
                $line = '[[line]]';
            }

            if ($continue === true) {
                // ==================================================================
                // START: Debug__wrapText sub function

                $output = Debug__wrapText(
                    $through_put, $debug_line, $debug_file, $debug_mode
                );

                // END: Debug__wrapText sub function
                // ==================================================================

                // ==================================================================
                // START: Debug__die sub function

                Debug__die($max_times, $force_die, $debug_line, $debug_file);

                // END: Debug__die sub function
                // ==================================================================
            }
        }

        if (!empty($output)) {
            return $output;
        }
    }

    /**
     * Defines configuration constants used by debug() and its sub functions
     *
     * @return void
     */
    function Debug__configInit()
    {
        if (!defined('DEBUG__CONF')) {
            $enviro_tmp = func_get_args();

            error_reporting(E_ALL | E_STRICT);
            $tmp = [
                'status' => true,
                'show_file' => true,
                'show_date' => false,
                'show_time' => false,
                'format' => 'auto', // html, text, comment, log, auto
                'mode' => 'echo', // echo, return, log
                'full_path' => false,
                'log_file' => '',
                'root_path' => '',
                'meta_max_length' => 40,
                'max_max_times' => 100
            ];

            $config = Debug__info($tmp);

            foreach ($enviro_tmp as $setting) {
                $setting = strtoupper($setting);
                switch ($setting) {
                case 'DEBUG__OFF':
                    $config['status'] = false;
                    break;

                case 'HIDE_FILE':
                    $config['show_file'] = false;
                    break;

                case 'TEXT':
                case 'TXT':
                    $config['format'] = 'text';
                    break;

                case 'XHTML':
                case 'HTML':
                case 'HTM':
                    $config['format'] = 'html';
                    break;

                case 'COMMENT':
                    $config['format'] = 'comment';
                    break;

                case 'RETURN':
                    $config['mode'] = 'return';
                case 'LOG':
                case 'LOG_CLEAN':
                case 'CLEAN':
                    $config['mode'] = 'log_clean';
                    break;

                case 'APPEND':
                case 'LOG_APPEND':
                    $config['mode'] = 'log_append';
                case 'FULL_PATH':
                    $config['full_path'] = true;
                    break;

                case 'TIME':
                    $config['show_time'] = true;
                    break;

                case 'DATE':
                    $config['show_date'] = true;
                    break;

                default:
                    if (is_writable($setting)) {
                        if (is_file($setting)) {
                            $config['log_file'] = $setting;
                        } elseif (is_dir($setting)) {
                            if (preg_match('/[\\/]/', $setting, $slash)) {
                                $setting = preg_replace(
                                    '/\\'.$slash[0].'$/',
                                    '',
                                    $setting
                                );
                                $config['log_file'] = $setting.$slash[0].
                                                      '.__DEBUG__LOG.txt';
                            }
                        };
                    } elseif (is_numeric($setting)) {
                        $config['meta_max_length'] = round($setting);
                    }
                    break;
                };
            };

            if (defined('DEBUG__STATUS')) {
                $status = Debug__statusCheck(DEBUG__STATUS);
                switch (strtolower(DEBUG__STATUS)) {
                case true:
                case 'on':
                case 'debug':
                case 'dev':
                case 'test':
                case 'testing':
                    $status = true;
                    break;

                case 'debug':
                    if (isset($_GET['debug'])) {
                        if ($_GET['debug'] == 'true' || $_GET['debug'] == 'debug') {
                            $status = true;
                        } else {
                            $status = false;
                        }
                    }
                    break;

                case false:
                case 'off':
                    $status = false;
                    break;
                }
            }

            if ($config['format'] == 'log' ) {
                $config['mode'] = 'log_clean';
                $config['format'] = 'text';
            }

            if (isset($_SERVER['PWD'])) {
                // running via the command line
                $config['root_path'] = $_SERVER['PWD'].'/';
                if ($config['format'] == 'auto') {
                    $config['format'] = 'text';
                }
            } elseif (isset($_SERVER['SCRIPT_FILENAME'])) {
                // running via the web
                $config['root_path'] = dirname($_SERVER['SCRIPT_FILENAME']).'/';

                if ($config['format'] == 'auto') {
                    $config['format'] = 'html';
                }
            } else {
                $backtrace = debug_backtrace();
                $bt_count = count($backtrace) - 1;
                $config['root_path'] = dirname($backtrace[$bt_count]['file']).'/';

                if ($config['format'] == 'auto') {
                    $config['format'] = 'html';
                }
            }

            if (ob_get_level() > 1 ) {
                if ($config['mode'] != 'log_append') {
                    $config['mode'] = 'log_clean';
                }

                $config['format'] = 'text';
            }

            Debug__define('DEBUG__STATE', $config['status']);
            Debug__define('DEBUG__MODE', $config['mode']);
            Debug__define('DEBUG__FORMAT', $config['format']);
            Debug__define('DEBUG__FULL_PATH', $config['full_path']);
            Debug__define('DEBUG__SHOW_FILE', $config['show_file']);
            Debug__define('DEBUG__SHOW_TIME', $config['show_time']);
            Debug__define('DEBUG__SHOW_DATE', $config['show_date']);
            Debug__define('DEBUG__ROOT_PATH', $config['root_path']);
            Debug__define('DEBUG__META_MAX_LENGTH', $config['meta_max_length']);
            Debug__define('DEBUG__MAX_MAX_TIMES', $config['max_max_times']);

            // ==================================================================
            // START: Debug__initialiseTxtWrapper()

            Debug__initialiseTxtWrapper();

            // END: debug_intialise_txt_wrapper()
            // ==================================================================

            // ==================================================================
            // START: Debug__logInit sub function

            Debug__logInit($config['log_file']);

            // END: Debug__logInit sub function
            // ==================================================================

            // ==================================================================
            // START: record predefined variable and constant names

            Debug__compactNames('vars');
            Debug__compactNames('const');

            // END: record predefined variable and constant names
            // ==================================================================

            define('DEBUG__CONF', true);
        }
    }

    /**
     * Check if a constant has been defined and then, if not, define it using
     * the supplied value.
     *
     * @param string  $constant_name    Name of constant
     * @param mixed   $value            Value to assign to the constant
     *                                  (if it's not already defined)
     * @param boolean $case_insensitive Whether or not the constant should
     *                                  name should be case sensitive
     *
     * @return boolean TRUE  if function defines constant or
     *                 FALSE if the constant is already defined.
     */
    function Debug__define($constant_name, $value, $case_insensitive = false)
    {
        if (!defined($constant_name)) {
            if ($case_insensitive !== false) {
                $case_insensitive = true;
            }

            define($constant_name, $value, $case_insensitive);
            return true;
        } else {
            return false;
        }
    }

    /**
     * Make content safe to render in a page
     *
     * @param string $input String to be sanitised
     *
     * @return string
     */
    function Debug__sepcialChars($input)
    {
        if (DEBUG__FORMAT != 'text') {
            return htmlspecialchars($input);
        } else {
            return $input;
        }
    }

    /**
     * Check the valuse of $test_status against allowable parameters
     * and returns TRUE or FALSE accordingly.
     *
     * @param mixed $test_status Value to be tested
     *
     * @return boolean $status
     */
    function Debug__statusCheck($test_status)
    {
        $status = false;
        switch (strtolower($test_status)) {
        case 'true':
        case 'on':
        case 'dev':
        case 'test':
        case 'testing':
            $status = true;
            break;

        case 'debug':
            if (isset($_GET['debug'])) {
                if ($_GET['debug'] == 'true' || $_GET['debug'] == 'debug') {
                    $status = true;
                } else {
                    $status = false;
                }
            }
            break;
        }
        return $status;
    }

    /**
     * Set up the appropariate strings to wrap various bits of the
     * debug output in.
     *
     * Defines three constants:
     *   'DEBUG__MSG_WRAPPER' - the whole debug message wrapper
     *   'DEBUG__MSG_BREAK'  -  line break replacement
     *   'DEBUG__MSG_META'   -  line number and file name replacement string.
     *
     * These constants will be used by debut__wrap_text()
     *
     * @return void
     */
    function Debug__initialiseTxtWrapper()
    {
        $current_file = '';
        $open = '';
        $close = '';
        $break = "\n[[LEADING_SPACE]]";
        $meta = '';

        if (!DEBUG__SHOW_FILE) {
            $current_file = '';
        } else {
            if (DEBUG__FULL_PATH) {
                $current_file = DEBUG__ROOT_PATH.'[[CURRENT_FILE]]';
            } else {
                $current_file = '[[CURRENT_FILE]]';
            }
        }
        if (empty($current_file)) {
            $meta = 'Line [[LINE_NUMBER]] ';
        } else {
            $meta = $current_file.'  Line [[LINE_NUMBER]]';
        }

        if (DEBUG__SHOW_DATE === true) {
            $meta .= '  [[DATE]]';
        }

        if (DEBUG__SHOW_TIME == true) {
            $meta .= ' [[TIME]]';
        }

        $meta = '('.$meta.')';

        switch (DEBUG__FORMAT) {
        case 'text':
            $open = "\n----------------------------------".
                    "-------------------------\n[[META]]";
            $close = "\n";
            break;
        case 'comment':
            $open = "\n<!--\n[[META]]\n";
            $close = "\n-->\n";
            break;
        case 'html':
            $open = "\n<pre class=\"debug-msg\"><strong>[[META]]</strong>";
            $close = "</pre>\n";
            break;
        }

        Debug__define('DEBUG__MSG_WRAPPER', $open.'[[DEBUG__MESSAGE]]'.$close);
        Debug__define('DEBUG__MSG_BREAK', $break);
        Debug__define('DEBUG__MSG_META', $meta);
    }



    /**
     * Set up the log file to accecpt debug log info.
     *
     * @param $log_path string full path and name of log file.
     *
     * @return void
     */
    function Debug__logInit($log_path)
    {
        $included = debug_backtrace();
        $root_file = ( count($included) - 1 );
        $debug_file = pathinfo($included[$root_file]['file']);
        $heading = 'Debug output for '.$debug_file['basename'].
                   ' ('.date('Y-m-d H:i').')';
        $content = '';

        if (empty($log_path)) {
            $log_path = $debug_file['dirname'].'/';
        }

        if (defined('DEBUG__HIDE_LOG') && DEBUG__HIDE_LOG === true) {
            $hide_log = '.';
        } else {
            $hide_log = '';
        }

        if (!empty($log_path) && is_dir($log_path) && is_readable($log_path)) {
            Debug__define(
                'DEBUG__LOG_FILE',
                $hide_log.'Debug__log.'.
                preg_replace('/[^-a-z0-9_]/i', '-', $debug_file['basename'])
            );

            if (!file_exists(DEBUG__LOG_FILE)) {
                $mode = 'log_clean';
            } else {
                $mode = DEBUG__MODE;
            }

            switch ($mode) {
            case 'log_clean':
                switch (DEBUG__FORMAT) {
                case 'htm':
                case 'html':
                    $content = '
<!DOCTYPE html>
<html lang="en-au">
    <head>
        <meta charset="utf-8" />
		<meta http-equiv="X-UA-Compatible" content="IE=edge" />
		<meta name="viewport"
              content="user-scalable=yes, initial-scale=1.0,
              width=device-width, height=device-height" />
        <title>'.$heading.'</title>
    </head>
    <body>
        <h1>'.$heading.'</h1>
    </body>
</html>
';
                    break;

                default:
                    $content = "=============================================".
                                "=======================\n$heading\n";
                    break;

                };
                break;

            case 'log_append':
                $content = file_get_contents(DEBUG__LOG_FILE);
                switch(DEBUG__FORMAT)
                {
                case 'htm':
                case 'html':
                    $content = str_ireplace(
                        '</body>',
                        "\t<hr />\n\t\t<h1>$heading</h2>\n\t</body>",
                        $content
                    );
                    break;
                default:
                    $content .= "\n\n========================================".
                                "============================\n$heading\n";
                    break;
                };
            };
            if (!empty($content) && file_exists(DEBUG__LOG_FILE)
                && is_writable(DEBUG__LOG_FILE)
            ) {
                file_put_contents(DEBUG__LOG_FILE, $content);
            }
        } else {
            switch (DEBUG__MODE) {
            case 'log_clean':
            case 'log_append':
                $pre =  "\n<!-- ==============================".
                        "==================================\n";
                $post = "\n===================================".
                        "============================== -->\n";

                if (empty($log_path)) {
                    echo $pre."You have said that debug should output to a log ".
                         "file but you have not\nspecified where the log file ".
                         "should be put$post";
                } elseif (!is_dir($log_path)) {
                    echo $pre."The \"$log_path\" directory you specified is ".
                         "not directory.$post";
                } elseif (!is_writable($log_path)) {
                    echo $pre."The \"$log_path\" directory you specified for ".
                         "debugging is not writable.$post";
                }
                exit;
            }
        }
    }


    /**
     * Defines debug config defaults based on values from debug.info file
     * makes it easier to config debug
     *
     * A debug.info file would look something like this:
     * -------------------------------------------------------------------
     *  ; debug info file - This file defines DEBUG config for the current app
     *
     *  status = debug; true / false / on / off / dev / test / testing / debug
     *  ; (NOTE: "status = debug;" requires $_GET['debug'] to equal true or
     *  ;        debug otherwise debugging is switched off)
     *  show_file = true; true/false
     *  show_date = false; true/false
     *  show_time = false; true/false
     *  full_path = false; true/false
     *
     *  format = html; comment / html / log / text
     *  mode = echo; append / clean / echo / log / log_append / log_clean / return
     *  ; file name to output log to - if logging is active defaults
     *  ; to .Debug__log.[initial file name]
     *  ;log_file = ;
     *
     *  meta_max_length = 10;
     *  max_max_times = 13;
     * -------------------------------------------------------------------
     *
     * @param array $config List of default config options
     *
     * @return array
     */
    function Debug__info($config)
    {
        if (file_exists('debug.config.json')) {
            try {
                $info = json_decode(file_get_contents('debug.config.json'), true);
            } catch(Exception $e) {
                return;
            }
            foreach ($info as $key => $value) {
                switch ($key) {
                case 'status':
                    $config['status'] = Debug__statusCheck($value);
                    break;

                case 'format':
                    $config[$key] = Debug__formatCheck($value);
                    break;

                case 'mode':
                    $config['mode'] = Debug__modeCheck($value);
                    break;

                case 'show_file':
                case 'show_date':
                case 'show_time':
                case 'full_path':
                case 'hide_log':
                case 'show_full_path':
                    $config[$key] = Debug__boolCheck(
                        $value, $config[$key]
                    );
                    break;

                case 'meta_max_length':
                case 'max_max_times':
                    $config[$key] = Debug__intCheck($value, $config[$key]);

                case 'log_file':
                    $config['log_file'] = Debug__fileCheck(
                        $value, $config['log_file']
                    );
                    break;
                }
            }
        } elseif (file_exists('debug.info')) {
            $info = file_get_contents('debug.info');
            $info_regex = '/(?<=[\r\n]|^)([^;\t =\r\n]+)[\t ]+[:=][ \t]+([^ \t;\r\n]+)(?:;.*)?(?=[\r\n])/iU'; // phpcs:ignore

            if (preg_match_all($info_regex, $info, $matches, PREG_SET_ORDER)) {
                if (!empty($matches)) {
                    foreach ($matches as $conf) {
                        if (!empty($conf)) {
                            $key = strtolower($conf[1]);
                            $value = strtolower($conf[2]);
                            switch ($key) {
                            case 'status':
                                $config[$key] = Debug__statusCheck($value);
                                break;

                            case 'format':
                                $config[$key] = Debug__formatCheck($value);
                                break;

                            case 'mode':
                                $config[$key] = Debug__modeCheck($value);
                                break;

                            case 'show_file':
                            case 'show_date':
                            case 'show_time':
                            case 'full_path':
                            case 'hide_log':
                            case 'show_full_path':
                                $config[$key] = Debug__boolCheck(
                                    $value, $config[$key]
                                );
                                break;

                            case 'meta_max_length':
                            case 'max_max_times':
                                $config[$key] = Debug__intCheck(
                                    $value, $config[$key]
                                );
                                break;

                            case 'log_file':
                                $config['log_file'] = Debug__fileCheck(
                                    $value, $conf[2]
                                );
                                break;
                            }
                        }
                    }
                }
            }
        }
        return $config;
    }


    /**
     * Define how many times the debug() function gets called in script
     * before it stops outputting debug messages
     *
     * @param integer $max_times  The maximum number of times this
     *                            function can be called.
     * @param integer $debug_line Line number debug() was called from
     * @param string  $debug_file Name of the file debug() was called
     *                            from
     *
     * @return boolean true if debugging should be shown, false if not
     */
    function Debug__maxTimes($max_times, $debug_line, $debug_file)
    {
        $output = null;

        if (!defined('DEBUG__DISCONTINUE_'.$debug_line)) {
            if (!is_numeric($max_times)) {
                // $max_times = 0;
                return;
            } elseif ($max_times > DEBUG__MAX_MAX_TIMES) {
                $max_times = DEBUG__MAX_MAX_TIMES;
            }

            $time_id = preg_replace(
                '/[^a-z0-9]+/i',
                '_',
                $debug_file.'_'.$debug_line.'_'
            );

            if ($max_times > 0) {
                if (!defined('DEBUG__DO_'.$time_id.'1')) {
                    while ($max_times > 0) {
                        if (!defined('DEBUG__DO_'.$time_id.$max_times)) {
                            define('DEBUG__DO_'.$time_id.$max_times, true);
                            $output = true;
                        }
                        $max_times -= 1;
                    }

                    $output = false;
                } else {
                    $output = false;
                }
            } else {
                $output = true;
            }

            if ($output === false) {
                define('DEBUG__DISCONTINUE_'.$debug_line, true);
            }
        } else {
            return false;
        }
    }

    /**
     * Kill your script after debug() has been called a specified
     * number of times
     *
     * When $max_times has been exhausted, and force_die is true, this
     * kills the whole script. This is useful when trying to debug a
     * script with an infinite loop.
     *
     * @param $max_times integer number of times debug should run
     * @param $force_die boolean kill the script or not.
     *
     * @return void
     */
    function Debug__die($max_times, $force_die)
    {
        if (defined('DEBUG__DO_1') && $force_die === true) {
            if ($max_times > 1) {
                $suffix = 's';
            } else {
                $suffix = '';
            }

            $message = 'debug() has killed your script after '.$max_times.
                       ' time'.$suffix.'. (at your request)';

            Debug__dieWithInfo($message, DEBUG__DIE_WITH_INFO__NO_VAR, 2);
        }
    }

    /**
     * Interpret a value as boolean
     *
     * @param mixed   $input    Value to be interpreted
     * @param boolean $_default Default value if value couldn't be
     *                          reliably interpreted
     *
     * @return boolean
     */
    function Debug__boolCheck($input, $_default) : bool
    {
        $input = is_string($input)
            ? strtolower($input)
            : $input;

        if ($input === true || $input === 'true'
            || $input === '1' || $input === 1
            || $input === 'yes' || $input === 'on'
        ) {
            return true;
        } elseif ($input === false || $input === 'false'
            || $input === '0' || $input === 0
            || $input === 'no' || $input === 'off'
        ) {
            return false;
        } else {
            return $_default;
        }
    }

    /**
     * Get a value that can be used as a `format` value
     *
     * @param string $input Value to be tested
     *
     * @return string valid `format` value
     */
    function Debug__formatCheck($input) : string
    {
        $input = strtolower($input);
        switch ($input) {
        case 'auto':
        case 'comment':
        case 'log':
        case 'html':
            return $input;

        case 'htm':
        case 'xhtml':
            return 'html';

        case 'text':
        case 'txt':
            return 'text';

        case 'cmnt':
            return 'comment';

        default:
            return 'auto';
        }
    }

    /**
     * Get a value that can be used as a `mode` value
     *
     * @param string $input Value to be tested
     *
     * @return string valid `mode` value
     */
    function Debug__modeCheck($input) : string
    {
        switch ($input) {
        case 'echo':
        case 'return':
        case 'log_append':
        case 'log_clean':
            return $input;

        case 'append':
            return 'log_append';

        case 'clean':
        case 'log':
            return 'log_clean';

        default:
            return 'echo';
        };
    }

    /**
     * Get a positive integer
     *
     * @param mixed   $input    value to be tested
     * @param integer $_default default value if input is invalid
     *
     * @return integer
     */
    function Debug__intCheck($input, $_default) : int
    {
        if (is_numeric($input)) {
            settype($input, 'integer');

            if ($input > 0) {
                return $input;
            }
        }
        return $_default;
    }

    /**
     * Get a file that exists, is readable & is writable
     *
     * @param string $input    File name to be tested
     * @param string $_default Default file name
     *
     * @return string
     */
    function Debug__fileCheck($input, $_default) : string
    {
        return (is_file($input) && is_readable($input)
            && is_writable($input))
            ? $input
            : $_default;

    }



    define(
        'DEBUG__DIE_WITH_INFO__NO_VAR',
        '{[ NO_INPUT_SUPPLIED - '.microtime().' ]}'
    );

    /**
     * Output a message for invalid function input parameters to be used
     * in a die() call. It appends the line number and file name of the
     * function with the invalid parameter was called from.
     *
     * @param string  $message    output message to be used
     * @param mixed   $dead_input input whose type is to be reported
     * @param integer $depth      how far down the backtrace to get info.
     *
     * @const DEBUG__DIE_WITH_INFO__NO_VAR unique no test variable value to
     *                                     ensure input type check is not
     *                                     matched incorrectly
     *
     * @return string full die message with line number file name and input
     *                type (if supplied)
     */
    function Debug__dieWithInfo(
        $message = '',
        $dead_input = DEBUG__DIE_WITH_INFO__NO_VAR,
        $depth = 1
    ) {
        if (!is_string($message)) {
            $output_msg = 'Debug__dieWithInfo() expects first parameter '.
                          '1 to be a string '.gettype($message).' found instad.';
            $depth = 0;
        } else {
            $output_msg = $message;
        }

        $back_trace = debug_backtrace();

        if ($dead_input != DEBUG__DIE_WITH_INFO__NO_VAR) {
            $output_msg .= ' '.gettype($dead_input).' found';
        }

        $output_msg .= " on line {$back_trace[$depth]['line']} of ".
                       "{$back_trace[$depth]['file']}.\n";

        if ($message == '') {
            return $output_msg;
        } else {
            die($output_msg);
        };
    };


    /**
     * Write debug output to log file
     *
     * @param $input string debugging info to be added to the log file.
     *
     * @return void
     */
    function Debug__log(&$input)
    {
        if (is_file(DEBUG__LOG_FILE)
            && is_readable(DEBUG__LOG_FILE)
            && is_writable(DEBUG__LOG_FILE)
        ) {
            switch (DEBUG__MODE) {
            case 'log':
            case 'log_clean':
            case 'log_append':
                switch (DEBUG__FORMAT) {
                case 'html':
                case 'htm':
                    file_put_contents(
                        DEBUG__LOG_FILE,
                        str_ireplace(
                            '</body>',
                            "\n$input\n\t</body>",
                            file_get_contents(DEBUG__LOG_FILE)
                        ),
                        FILE_APPEND
                    );
                    break;

                default:
                    file_put_contents(
                        DEBUG__LOG_FILE, $input, FILE_APPEND
                    );
                }
            }
        }
    }

    /**
     * Apply formatting to the debug message.
     *
     * @param string  $msg        Debug  message to be displayed or logged
     * @param integer $debug_line Line number
     * @param string  $debug_file file name
     * @param string  $debug_mode Debug mode
     *
     * @const DEBUG__MSG_WRAPPER string that will be used to format the
     *        whole message
     * @const DEBUG__MSG_META strng that will contain the file name and
     *        line number debug was called from.
     * @const DEBUG__MSG_BREAK string that will be used to substitute
     *        line break and leading white space
     *
     * @return string, void
     */
    function Debug__wrapText(
        &$msg, $debug_line, $debug_file, $debug_mode = DEBUG__MODE
    ) {
        $timestamp = time();
        $date = '';
        $time = '';
        $wrapper = DEBUG__MSG_WRAPPER;

        if (DEBUG__SHOW_DATE === true) {
            $date = date(' Y-m-d', $timestamp);
        }

        if (DEBUG__SHOW_TIME == true) {
            $time = date(' H:i', $timestamp);
        }

        $debug_file = str_replace(DEBUG__ROOT_PATH, '', $debug_file);

        $meta = str_replace(
            array( '[[LINE_NUMBER]]', '[[CURRENT_FILE]]', '[[DATE]]', '[[TIME]]'),
            array($debug_line, $debug_file, $date, $time),
            DEBUG__MSG_META
        );

        $meta_length = strlen($meta);

        if ($meta_length > DEBUG__META_MAX_LENGTH) {
            $meta_length = 5;
            $meta .= '[[LINE]]';
        } else {
            $msg = ' '.$msg;
            $wrapper = str_replace(']][[', ']] [[', $wrapper);
        }

        $leading_space = '';

        for ($a = $meta_length; $a > 0; $a -= 1) {
            $leading_space .= ' ';
        }

        $break = str_replace(
            '[[LEADING_SPACE]]', $leading_space, DEBUG__MSG_BREAK
        );

        $output = str_ireplace(
            array('[[META]]', '[[DEBUG__MESSAGE]]', '[[LINE]]'),
            array($meta, $msg, $break),
            $wrapper
        );

        unset($date, $time, $timestamp, $meta, $meta_length, $leading_space, $break);
        switch ($debug_mode) {
        case 'log':
        case 'log_clean':
        case 'log_append':
            Debug__log($output);
            break;
        case 'return':
            return $output;
            break;
        default:
            echo $output;
            break;
        }

        return '';
    }


    /**
     * Outputs help info on how to use debug()
     *
     * @param array $arr 'debug' - info about using debug()
     *                   'conf'  - info about setting up environment
     *                   parameters for debug() (includes
     *                   both 'info' and 'Debug__conf' plus
     *                   some extra stuff)
     *                   'info'  - info about the info file
     *                   'Debug__conf'  - info about using Debug__conf()
     *                   NULL / empty array - everything
     *
     * @return void Outputs everything to screen.
     */
    function Debug__help(&$arr)
    {
        $helpFile = __DIR__.'/debug_help.inc.php';

        if (is_file($helpFile)) {
            $content['debug']['title'] = "\n".'<h2>Using '.
                                        '<span class="function">'.
                                        'debug()</span></h2>'."\n";
            $content['debug']['menu'] = '';
            $content['debug']['content'] = file_get_contents($helpFile);

            $output = '';
            $help_mode = Debug__helpMode($arr);

            // if (isset($$help_mode)) {
            //     echo "<h2>".$content[$help_mode]['title']."</h2>\n".$content[$help_mode]['menu']."\n\n".$content[$help_mode]['content'];
            // } else {
            //     $menu = '<ul>';
            //     $output = '<hr />';
            //     foreach ($content as $mode) {
            //         $menu .= "\n<li>{$mode['title']}\n{$mode['menu']}\n</li>\n";
            //         $output .= "\n\n{$mode['content']}\n\n";
            //     };
            //     echo "$menu</ul>\n\n$output";
            // }

            echo $content['debug']['content'];
        } else {
            debugDebug('Unable to find debug help file in '.$helpFile);
        }
    }

    /**
     * Recursive cascade through an array looking for a valid help mode
     * value then returns that value.
     *
     * @param string,array $arr Help mode
     * @param boolean      $end string or array
     *
     * @return string
     */
    function Debug__helpMode($arr, &$end = false)
    {
        $output = '';
        if ($end == false) {
            $help_mode = '';
            if (is_array($arr)) {
                if (!empty($arr)) {
                    for ($a = 0; $a < count($arr); $a += 1) {
                        $help_mode = Debug__helpMode($arr[$a], $end);
                        if ($end === true) {
                            $a = count($arr);
                        }
                    }
                }
            } else {
                $help_mode = $arr;
            }

            $help_mode = strtolower($help_mode);

            switch ($help_mode) {
            case 'debug':
            case 'info':
            case 'debug_conf':
            case 'config':
                $output = $help_mode;
                $end = true;
                break;
            }
        }

        return $output;
    }

    /**
     * Transform whitespace characters into visual representation of
     * same characters
     *
     * @param string $input String with white space chars made visible
     *
     * @return string
     */
    function Debug__whitespace($input)
    {
        $find = array(
            "\n"
           , "\r"
           , "\t"
           , ' '
        );
        $replace = array(
            '\n'
           , '\r'
           , '\t'
           , '[[SPACE]]'
        );
        return str_replace($find, $replace, $input);
    };

    /**
     * Attempt to find the name of the variable that owns the current
     * value
     *
     * @param mixed $var_value       Value of variable
     * @param array $var_name        Potential name of variable
     * @param array $current_globals List of known global variables
     *
     * @return void
     */
    function Debug__getVarName($var_value, &$var_name, $current_globals)
    {
        $tmp_name = '';
        foreach ($current_globals as $globals_var_name => $globals_var_value) {
            if ($globals_var_value === $var_value) {
                $tmp_name = '$'.$globals_var_name;
            } elseif (is_array($globals_var_value)
                && $globals_var_name != 'GLOBALS'
            ) {
                Debug__getVarNameFromArray(
                    $tmp_name, $var_value, $globals_var_name, $globals_var_value
                );
            }

            if ($tmp_name !== ''
                && Debug__noVarNameAlready($tmp_name, $var_name) === true
            ) {
                $var_name['count'] += 1;
                if ($var_name['count'] > 1) {
                    $var_name['extra'] .= $var_name['space'].$tmp_name;
                    $var_name['space'] = ' or ';
                } else {
                    $var_name['name'] = $tmp_name.' ';
                }
            }
        }
    }

    /**
     * Attempt to match a the supplied var value to a value within an array
     * from the globals array.
     *
     * @param string $t_name    temporary variable name
     * @param mixed  $var_value supplied variable value to be matched against
     * @param string $g_name    name of global variable to be matched against
     * @param mixed  $g_value   value of global variable to be matched against
     *
     * @return void
     */
    function Debug__getVarNameFromArray(&$t_name, $var_value, $g_name, $g_value)
    {
        foreach ($g_value as $t_key => $t_value) {
            if ($t_key != 'GLOBALS') {
                $t1_name = $g_name.'['.$t_key.']';
            } else {
                $t1_name = $t_key;
            }

            if ($var_value === $t_value && substr_compare($t_key, 'DEBUG__', 0, 7)) {
                if ($t_name == '') {
                    $t_name = $t1_name;
                } else {
                    return;
                };
            } elseif (is_array($t_value) && $t_key != 'GLOBALS') {
                Debug__getVarNameFromArray(
                    $t_name, $var_value, $t1_name, $t_value
                );
                if ($t_name != '') {
                    return;
                }
            }
        }
    }

    /**
     * Check to see if a given value matches exactly the value of a
     * defined constant.
     *
     * @param mixed  $var_value     Variable value
     * @param string $var_name      Variable name
     * @param mixed  $current_const List of constants
     * @param bool   $user_const    (I don't know)
     *
     * @return void
     */
    function Debug__getConstName(
        &$var_value, &$var_name, $current_const, $user_const = false
    ) {
        $all_const = false;

        if (is_string($var_value)) {
            switch ($var_value) {
            case 'help':
            case '?':
            case 'backtrace':
            case 'server':
            case 'request':
            case 'get':
            case 'post':
            case 'env':
            case 'files':
            case 'session':
            case 'cookie':
            case 'global':
            case 'globals':
            case 'forcedie':
            case 'force die':
            case 'force_die':
            case 'force-die':
            case 'config':
                return;

            default:
                if (preg_match('/^max[- _]times ?(?:= ?)?([0-9]*)$/', $var_value)) {
                    return;
                }
            }
        } elseif (!is_bool($var_value) && !is_numeric($var_value)) {
            return;
        }

        if ($var_name['name'] != '' && $var_name['extra'] != '') {
            $var_name_space = ' or ';
        } else {
            $var_name_space = '';
        }

        if ($user_const === true ) {
            $var_name = 'Sript defined CONSTANTS = ';
            $var_value = $current_const;
            return;
        } else {
            foreach ($current_const as $key => $value) {
                if ($value === $var_value) {
                    if ($var_name['name'] == '' ) {
                        $var_name['name'] = '"'.$key.'" ';
                    } else {
                        $var_name['extra'] .= $var_name_space.'"'.$key.'" ';
                        $var_name_space = ' or ';
                    }
                }
            }
        }

        return;
    }


    /**
     * No variable name
     *
     * @param mixed $tmp_name temproary name
     * @param mixed $var_name varialbe name
     *
     * @return bool
     */
    function Debug__noVarNameAlready($tmp_name, $var_name)
    {
        $v_name = $var_name['name'].$var_name['extra'];
        $output = substr_count($v_name, $tmp_name);

        if ($output == 0) {
            return true;
        } else {
            return false;
        }
    }

    /**
     * Define a constant for the given type
     *
     * @param string $type Variable type
     *
     * @return void
     */
    function Debug__compactNames($type = 'vars')
    {
        if ($type != 'vars') {
            $type = 'CONST';
            $input = get_defined_constants();
        } else {
            $type = 'VARS';
            $input = $GLOBALS;
        }

        $tmp = '';
        $tmp_sp = '';

        foreach ($input as $key => $var ) {
            $tmp .= $tmp_sp.$key;
            $tmp_sp = ', ';
        };
        define('DEBUG__PRE_DEFINED_'.$type, $tmp);
    }

    /**
     * Get a list of variables defined by the script
     *
     * @return array
     */
    function Debug__scriptVarsOnly()
    {
        $output = array();
        $pre_defined = Debug__extractNames('vars');

        foreach ( $GLOBALS as $key => $value ) {
            if (!isset($pre_defined[$key])
                || (strlen($key) > 7
                && substr_compare($key, 'Debug__', 0, 7, true) == 0)
            ) {
                $output[$key] = $value;
            }
        }
        return $output;
    }


    /**
     * Get a list of constant defined by the script
     *
     * @return array
     */
    function Debug__scriptConstOnly()
    {
        $output = get_defined_constants();
        $pre_defined = Debug__extractNames('const');

        foreach ($pre_defined as $key => $value) {
            if (isset($output[$key])
                || (strlen($key) > 7
                && substr_compare($key, 'Debug__', 0, 7, true) == 0)
            ) {
                unset($output[$key]);
            }
        }
        return $output;
    }

    /**
     * Not sure what this is for
     *
     * @param string $type Type of thing to extract
     *
     * @return array
     */
    function Debug__extractNames($type = 'vars')
    {
        $output = array();
        if ($type != 'vars') {
            $tmp = explode(', ', DEBUG__PRE_DEFINED_CONST);
        } else {
            $tmp = explode(', ', DEBUG__PRE_DEFINED_VARS);
        }

        for ($a = 0; $a < count($tmp); $a += 1) {
            $b = $tmp[$a];
            $output[$b] = '';
        }
        return $output;
    }



    // ==================================================================
    // The following is for debugging the above functions.

    /**
     * Used for debugging other functions in debug.inc.php
     * echos formatted debug info.
     *
     * @param $msg mixed (usually string)
     * @param $arr array values to output
     *
     * @return void
     */
    function debugDebug($msg = '', $arr = array())
    {
        error_reporting(E_ALL | E_STRICT);
        $output = '';
        $included = debug_backtrace();
        $debug_line = $included[0]['line'];
        $debug_file = $included[0]['file'];
        unset($included);
        if (is_array($msg)) {
            $arr = $msg;
            $msg = '';
        }

        if (!empty($arr)) {
            $arr = '[[line]]'.Debug__sepcialChars(print_r($arr, true));
        } else {
            $arr = '';
        }

        if (defined('DEBUG__FORMAT') && DEBUG__FORMAT == 'text') {
            echo "\n-----------------------------------------------------------".
                 "\n(DEBUG_DEBUG() line $debug_line)\n".
                 str_ireplace('[[line]]', "\n", $msg.$arr)."\n";
        } else {
            echo '<pre><strong>(line '.$debug_line.')</strong> '.
                 str_ireplace('[[line]]', "\n", $msg.$arr).'</pre>';
        }
    }

    // ==================================================================
    // The following is for debugging the above functions.

    /**
     * Used for debugging other functions in debug.inc.php
     * echos formatted debug info. (Outputs to log file rather than screen)
     *
     * @param $msg mixed (usually string)
     * @param $arr array
     *
     * @return void
     */
    function debugLog($msg='', $arr=array())
    {
        error_reporting(E_ALL | E_STRICT);
        $output = '';
        $included = debug_backtrace();
        $debug_line = $included[0]['line'];
        $debug_file = $included[0]['file'];

        unset($included);

        if (is_array($msg)) {
            $arr=$msg;
            $msg='';
        }

        if (!empty($arr)) {
            $arr='[[line]]'.Debug__sepcialChars(print_r($arr, true));
        } else {
            $arr='';
        }

        file_put_contents(
            DEBUG__LOG_FILE,
            "\n-----------------------------------------------------------".
            "\n(DEBUG_DEBUG() line $debug_line)\n".
            str_ireplace('[[line]]', "\n", $msg.$arr)."\n",
            FILE_APPEND
        );
    }

    /**
     * Get debug info about parent context
     *
     * @param mixed $input stuff to output
     *
     * @return void
     */
    function debugParent($input)
    {
        $parent = debug_backtrace();debug($parent);
        if (isset($parent[2])) {
            $debug_line = $parent[1]['line'];
            $debug_file = $parent[1]['file'];

            Debug__wrapText($input, $debug_line, $debug_file);

            return;
        }
    }

    Debug__configInit();

    // The following constant declarations are just here for PHP
    // intelisense in VSCode or whatever IDE you're using.

    // All these constants should already be defined above but
    // because of the way they're defined, intelisense can't see
    // they're defined. This is here to iliminate error reporting
    // in your IDE
    if (!defined('DEBUG__STATE')) { define('DEBUG__STATE', false); } // phpcs:ignore
    if (!defined('DEBUG__STATUS')) { define('DEBUG__STATUS', false); } // phpcs:ignore
    if (!defined('DEBUG__MODE')) { define('DEBUG__MODE', 'echo'); } // phpcs:ignore
    if (!defined('DEBUG__FORMAT')) { define('DEBUG__FORMAT', 'auto'); } // phpcs:ignore
    if (!defined('DEBUG__FULL_PATH')) { define('DEBUG__FULL_PATH', false); } // phpcs:ignore
    if (!defined('DEBUG__SHOW_FILE')) { define('DEBUG__SHOW_FILE', true); } // phpcs:ignore
    if (!defined('DEBUG__SHOW_TIME')) { define('DEBUG__SHOW_TIME', false); } // phpcs:ignore
    if (!defined('DEBUG__SHOW_DATE')) { define('DEBUG__SHOW_DATE', false); } // phpcs:ignore
    if (!defined('DEBUG__ROOT_PATH')) { define('DEBUG__ROOT_PATH', ''); } // phpcs:ignore
    if (!defined('DEBUG__META_MAX_LENGTH')) { define('DEBUG__META_MAX_LENGTH', 40); } // phpcs:ignore
    if (!defined('DEBUG__MAX_MAX_TIMES')) { define('DEBUG__MAX_MAX_TIMES', 100); } // phpcs:ignore
    if (!defined('DEBUG__LOG_FILE')) { define('DEBUG__LOG_FILE', ''); } // phpcs:ignore
    if (!defined('DEBUG__HIDE_LOG')) { define('DEBUG__HIDE_LOG', true); } // phpcs:ignore
    if (!defined('DEBUG__MSG_WRAPPER')) { define('DEBUG__MSG_WRAPPER', ''); } // phpcs:ignore
    if (!defined('DEBUG__MSG_META')) { define('DEBUG__MSG_META', ''); } // phpcs:ignore
    if (!defined('DEBUG__MSG_BREAK')) { define('DEBUG__MSG_BREAK', ''); } // phpcs:ignore
    if (!defined('DEBUG__PRE_DEFINED_CONST')) { define('DEBUG__PRE_DEFINED_CONST', ''); } // phpcs:ignore
    if (!defined('DEBUG__PRE_DEFINED_VARS')) { define('DEBUG__PRE_DEFINED_VARS', ''); } // phpcs:ignore
} else {
    debug(
        'debug() has been defined elsewhere see debug_backtrace() output',
        debug_backtrace()
    );
}
